# PPLBandage Backend
<p align="left">
    <img src="https://made-with.prisma.io/indigo.svg" alt='prisma'></img> 
    <img src="https://img.shields.io/endpoint?url=https%3A%2F%2Fghloc.vercel.app%2Fapi%2FPPLBandage%2FPPLBandage_Backend%2Fbadge%3Ffilter%3D.ts%24%2C.tsx%24%2C.css%24" alt='prisma'></img> 
    <img src="https://andcool.ru/static/badges/made-for-ppl.svg" alt='pepeland'></img> 
    <img src="https://www.codefactor.io/repository/github/pplbandage/pplbandage_backend/badge" alt='pepeland'></img> 
</p>

## Оглавление
- [Base URL](#base-url)
- [Ограничения по частоте запросов](#ограничения-по-частоте-запросов)
- [Ошибки](#ошибки)
- [Аутентификация](#аутентификация)
- Документация к API
- - [Корневые эндпоинты API](/docs/mainRoute.md)
- - [Мастерская](/docs/workshop.md)
- - Пользователи
- - [Minecraft API](/docs/minecraft.md)
- - Auth

## Введение
**API PPLBandage — это RestFul API, позволяющий приложениям взаимодействовать с серверами и базой данных проекта.** 

> [!WARNING]
> Документация не всегда соответствует текущей версии API.

## Base URL
`https://pplbandage.ru/api/v1`

## Ограничения по частоте запросов
Глобальное ограничение на все эндпоинты: `150 запросов в 2 минуты`, однако оно может варьироваться в зависимости от конечного эндпоинта.
| Эндпоинт                                                  | Ограничение по частоте запросов |
| --------------------------------------------------------- | ------------------------------- |
| `GET /api/v1/ping`                                        | Нет                             |
| `GET /api/v1/users/@me/connections/minecraft/cache/purge` | `5rpm`                          |
| `POST /api/v1/workshop`                                   | `5rpm`                          |

## Ошибки
Всего может возникнуть несколько типов ошибок:
### Ошибки валидации
Ошибки валидации могут возникнуть, если в тело запроса или query параметры было передано неверное значение.
```json
{
    "message": [
        "Массив ошибок валидации"
    ],
    "error": "Описание кода ошибки",
    "statusCode": 400
}
```

### Общие ошибки
Общие ошибки могут возникнуть во всех остальных случаях, например, если пользователь не авторизован.
```json
{
    "statusCode": 401,
    "message": "UNAUTHORIZED"
}
```
a
## Аутентификация
Аутентификация происходит через **токены сессии**. 
### Описание процесса аутентификации
Токены сессии должны передаваться в cookies запроса по ключу `sessionId`.  
При создании запроса к API он проверяет валидность токена, время жизни которого равно `14 дням` или двум неделям. Если со времени создания токена прошло более половины от его времени жизни, то бекенд обновляет токен и отправляет клиенту в `Setcookie` хедере.
> [!NOTE]
> Обычно, все эндпоинты, требующие строгой аутентификации всегда отправляют `Setcookie` хедер, содержащий актуальный в данный момент токен сессии. В случае, когда токен был обновлён, он так же отправляется в хедерах. Клиенты должны при каждом запросе устанавливать актуальный токен из запроса.
>
> Запросы, не требующие строгой аутентификации обновлять токены <ins>не будут</ins>. Бекенд будет пытаться использовать переданный ему токен, пока у него не выйдет время жизни.

> [!WARNING]
> Бекенд **не поддерживает** выполнение параллельных запросов при обновлении токена. Клиенты должны сами позаботиться, чтобы запросы, подразумевающие обновление токена не выполнялись параллельно. В ином случае есть риск потерять текущую сессию.


<details>
<summary><b>Особенности работы</b></summary>

Комбинации запросов, требующих строгой аутентификации и нет могут вызвать неожиданное поведение!

Например, если выполняется сначала строгий запрос, а за ним нестрогий, последний может вернуть ошибку `401`.  
**Пояснение:**  
Первый запрос приходит на сервер и возвращает с собой новый идентификатор сессии, который может быть не использован при выполнении последующих запросов. Данная проблема требует грамотного решения по предотвращению выполнения параллельных запросов и своевременного обновления файлов куки клиента.    

Если не предотвращать параллельное выполнение запросов, то асинхронный бекенд может не обработать некоторые токены сессии, что приведет к неожиданному результату.    

**На стороне бекенда реализованны все возможные системы по предотвращению подобных случаев (в рамках спецификаций протокола HTTP), однако этого может быть недостаточно для корректной работы. Поэтому клиенты так же должны грамотно подходить к реализации работы с API.**
</details><br/>

Если время жизни токена закончилось, бекенд вернёт HTTP код `401`.  
Все сессии связываются с fingerprint'ом текущего клиента, который представлен `User-Agent` хедером. Если запрос делается с другого `User-Agent` и по этому же токену, то он автоматически удаляется, возвращая HTTP код `401`.
